# ================================================================================
#   script extracts IFT measurements and some metadata from 
#       experiments generated by scans derived from hld_ift_http project
#       to CSV files for post processing
# ================================================================================

# needs reworking to use in workflow!!!!

import json
import csv
import functools

path = "/mnt/i/temp/opentron/Brij_L4_C16-C7_v1/hexdec/exp_2025-01-09_001/data.json"
pathes = [path]

pathes = [
"/mnt/i/temp/opentron/Brij_L4_C16-C7_v1/hexdec/exp_2025-01-09_001/data.json",
"/mnt/i/temp/opentron/Brij_L4_C16-C7_v1/hexdec/exp_2025-01-10_001/data.json",
"/mnt/i/temp/opentron/Brij_L4_C16-C7_v1/hexdec/exp_2025-01-10_002/data.json",
"/mnt/i/temp/opentron/Brij_L4_C16-C7_v1/hexdec/exp_2025-01-13_003/data.json",
"/mnt/i/temp/opentron/Brij_L4_C16-C7_v1/hexdec/exp_2025-01-13_004/data.json",
"/mnt/i/temp/opentron/Brij_L4_C16-C7_v1/hexdec/exp_2025-01-13_005/data.json"
]
path_out = "/mnt/i/temp/opentron/Brij_L4_C16-C7_v1/hexdec/all_data_from_json.csv" 

def apply_values(a_dict, **params):
    if params is not None and len(params.keys()) > 0:
        for key in params.keys():
            a_dict[key] = params[key]
    return a_dict

#def read_measurement(a_dict):
#    
#
def read_image_record(source_dict, **params):
    out = source_dict.copy()
    apply_values(out, **params)
    return out

def read_measurement(source_dict, **params):
    #print("========================")
    #print(source_dict)
    #print(params)
    new_params = params.copy()
    new_params["measurement_label"] = source_dict["label"]
    new_params["solution_inner_ro"] = source_dict["solution_inner"]["ro"]
    new_params["solution_outer_ro"] = source_dict["solution_outer"]["ro"]
    new_params = read_solution_components(source_dict["solution_inner"], "si_", **new_params)
    new_params = read_solution_components(source_dict["solution_outer"], "so_", **new_params)
    #for i in source_dict["ift_images"]:
    #    read_image_record(i, **params)
    return list(map(lambda x: read_image_record(x, **new_params), source_dict["ift_images"]))

def read_scans(source_dict, **params):
    new_params = params.copy()
    new_params["needle_dia"] = source_dict["needle_dia"]
    #for scan in source_dict["scans"]:
    #    read_scan(scan, **params)
    return list(functools.reduce(lambda x, y: x + y, 
                        list(map(lambda x: read_scan(x, **new_params.copy()), 
                                source_dict["scans"])))) 

def read_scan(source_dict, **params):
    new_params = params.copy()
    new_params["scan_label"] = source_dict["label"]
    #for measurement in source_dict["measurements"]:
    #    read_measurement(measurement, **params)
    ##read_measurements(meas, scan_label = source_dict["label"], **params)
    if source_dict["measurements"] is None or len(source_dict["measurements"]) < 1:
        return list()
    return list(functools.reduce(lambda x, y: x + y, 
                        list(map(lambda x: read_measurement(x, **new_params.copy()), 
                                source_dict["measurements"])))) 

def read_solution_components(source_dict, prefix, **params):
    for comp in source_dict["components"].keys():
        params[f"{prefix}{comp}"] = source_dict["components"][comp]["w"]
    return params

def all_keys(alst):
    return list(functools.reduce(lambda x,y: x.union(y), 
                                list(map(lambda x: set(x.keys()), 
                                        alst))))

def process_file(path):
    with open(path, "r") as f:
        my_data = read_scans(json.loads(f.read()), myparam = 1)
    return my_data

def apply_missing_w(a_dict, keys):
    for k in keys:
        if k not in a_dict.keys():
            a_dict[k] = 0
    return a_dict

all_data = list(functools.reduce(lambda x, y: x + y, 
                        list(map(lambda x: process_file(x), 
                                pathes)))) 
                        
all_keys_ = all_keys(all_data)
all_data_a = list(map(lambda x: apply_missing_w(x, all_keys_), all_data))
all_data_1 = list(map(lambda x: json.loads(json.dumps(x, sort_keys = True)), all_data_a))


with open(path_out, "w") as f:
    csv_writer = csv.writer(f)
    status = True
    for i in all_data_1:
        if status:
            csv_writer.writerow(i.keys())
            status = False
        csv_writer.writerow(i.values())

